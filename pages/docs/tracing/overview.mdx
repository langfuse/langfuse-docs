---
description: An overview of how open source observability for LLM applications works with Langfuse.
---

# Tracing

LLM apps use increasingly complex abstractions (chains, agents with tools, advanced prompts). The nested traces in Langfuse help to understand what is going on and get to the root cause of problems.

Why use tracing for your LLM app?

1. Collect user feedback from the frontend
2. Filter down to executions that had poor quality
3. Use the debugging UI to get to the root cause of the problem

## Introduction

```mermaid
classDiagram
    Trace "1" *-- "n" Observation
    Observation <|-- Event
    Observation <|-- Span
    Observation <|-- Generation
    Observation o-- Observation: Nesting
```

A trace in Langfuse consists of the following objects:

- Each backend execution is logged with a single `trace`.
- Each trace can contain multiple `observations` to log the individual steps of the execution.
  - Observations are of different types:
    - `Events` are the basic building block. They are used to track discrete events in a trace.
    - `Spans` represent durations of units of work in a trace.
    - `Generations` are spans which are used to log generations of AI models. They contain additional attributes about the model, the prompt/completion. For generations, [token usage and costs](/docs/model-usage-and-cost) are automatically calculated.
  - Observations can be nested.

## Get Started

Follow the quickstart to add Langfuse tracing to your LLM app.

import { FiCode } from "react-icons/fi";
import { Rocket } from "lucide-react";
import { SiApplearcade } from "react-icons/si";

<Cards num={3}>
  <Card
    icon={<Rocket size="24" />}
    title="Quickstart"
    href="/docs/get-started"
    arrow
  />
</Cards>

## Demo

Check out the interactive demo to browse production traces in Langfuse.

<Cards num={3}>
  <Card
    icon={<SiApplearcade size="24" />}
    title="Interactive demo"
    href="/docs/demo"
    arrow
  />
</Cards>
